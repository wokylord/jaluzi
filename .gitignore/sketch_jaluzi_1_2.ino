/*
 * 25.06 работа с авт режимом
 *       -подключение авт режима (темно- закрыто, светло - открыто) 
 *       -сделан переход на авт режим независящий от положения жалюзи (до перехода ) . Делает максимум оборотов на закрытие (при достижении границы проворачивается/проскальзывает)и потом отькрывается реверсом*
 *       -подключение фоторезистора (1)
 *       Все функции сделаны в циклах. Это нужно улучшить.
 *       На улучшение 
 *        1- улучшить циклы 
 *        2- по возможности переработать реверс
 *        3- добавить фоторезистор на стол
 *        4- сделать несколько авт режимов и их выбор с пульта
 */
#include <IRremote.h>
IRrecv irrecv(2);                       // обозначаем выход датчика 
decode_results results;                 // инициализируем его 
                                        /* датчик VS1838B правая - питание, средняя - земля, левая сигнальная .
                                         *  питается от 5В через резистор на 100 Ом 
                                         *  между питанием и землей нужен конденсатор 4,7 uF но у меня стоит на 10 (+ на питание , - на землю)
                                         */ 
                                         //расттояние норм приема около 4 метров

#include <CustomStepper.h>             // Подключаем кастомную (не родную) библиотеку управления шаговым двигателем. По умолчанию настроена на двигатель 28BYJ-48-5V
CustomStepper stepper(8, 9, 10, 11);   //  задаем и Указываем пины, к которым подключен драйвер шагового двигателя

#define PhotRPinWindow A0              // пин фоторизистора на окне 5v на 1 ногу а к 2 ноге на А0 и рез 10ком на землю
#define PhotRPinTable A1               // пин фоторизитора на столе на пульте управления

#define PinLRED 7                      //пины RGB диода
#define PinLGreen 6 
#define PinLBlue 5

boolean FlagR = false ;                // влаги для RGB светодиода
boolean FlagG = false ;
boolean FlagB = false ;

boolean Auto = false ;                 // индикатор автоматического режима 0 - выкл 1 - вкл
boolean Revers = false ;

boolean Bflag = false ;                // флаги
boolean Modflag = false ; 
boolean Lightflag = false ;                
long last_press = 0  ;                 // переменная для хранения времени последнего нажатия
int PValueWindow = 0;                  // переменная для данных с фоторезистора
int PValueTable = 0;
int AutoMod = 100 ;                    // индикатор положения жалюзи в автоматическом режиме      

// настраиваемые значения
//между сравниваемыми значениями должен быть ощутимый разрыв около 100 пунктов чтобы система не колебалась тудя сюда
//=========================================НАСТРОЙКИ===================================================================================
// Освещенность
#define LightDark          100
#define LightBright        900
#define LightOutsideEvning 650
#define LightTableLamp     950 
#define LightTableMain     700

// Коды пульта
#define UP     0xE0E0E01F 
#define DWN    0xE0E0D02F
#define Change 0xE0E016E9
#define Exit   0xE0E0B44B

//Режим работы порта
#define Port   0       // 0 - выкл, 1 - скан кнопок пульта, 2 - вывод значений с фоторезисторов

//============================================================================================================================
                    
int mod = 0 ;                          // !!! исправить чтобы не клинило прогу на первом прогоне через stepper.run(); 
void setup()
{
  Serial.begin(9600);                  // открываем порт

    
  pinMode(PhotRPinWindow, INPUT);      // обозначение входа на прием аналогового сигнала с фоторезистора 
  pinMode(PhotRPinTable, INPUT);

  pinMode (PinLRED, OUTPUT);           // обозначаем пины диода как пин выхода
  pinMode (PinLGreen, OUTPUT); 
  pinMode (PinLBlue, OUTPUT); 
  
  irrecv.enableIRIn();                 // запуск приема с ИК датчика

  stepper.setRPM(12);                  // Устанавливаем кол-во оборотов в минуту. 12 оптимально для 28BYJ-48-5V
  stepper.setSPR(4075.7728395);        // Устанавливаем кол-во шагов на полный оборот. Максимальное значение 4075.7728395 для 28BYJ-48-5V
}

void loop() {

  PValueWindow=analogRead(PhotRPinWindow);  // присваеваем переменной сигнал с аналогового пин
 // PValueTable=analogRead(PhotRPinTable);

  digitalWrite(PinLBlue, Auto );             // зажигаем или гасим светодиод в зависимости от Auto
  
// цикл вывода данных с датчика в порт
  if (stepper.isDone()&& Port == 2){        // ВАЖНО !!! порт не клинит работу только когда выводит игформацию когда степпер не занят
    Serial.print("Window = ");
    Serial.print(PValueWindow);             // вывод значения с фоторезистора в порт  (от 0 до 1000 примерно)
    //Serial.print(" || Table = ");
    //Serial.print(PValueTable);
    Serial.println();
  }
  
//цикл настройки пульта
  if (stepper.isDone()&& Port == 1){
    if ( irrecv.decode(&results)){            //если что то есть на приеме &-ссылка хз как работает
      Serial.println (results.value, HEX);    //то выводим это в 16-ричной системе
      irrecv.resume();                        // переводим датчик на чтение 
    }
  }

//цикл автоматического режима после реверса* закрывает когда темно и открывает когда светло
  if (stepper.isDone()&&Port == 0 && Auto == true && Revers == true){
    if (AutoMod == 0 && PValueWindow < LightOutsideEvning - 50){
      stepper.setDirection(CW);          // зарывает
      stepper.rotateDegrees(220);
      
      AutoMod = 1;                       // говорим что закрыты
    }


    if (AutoMod == 1 && PValueWindow > LightOutsideEvning + 50 ){
      stepper.setDirection(CCW);         // открываем
      stepper.rotateDegrees(220);
      AutoMod = 0;                       // говорим что открыты
    }
  }

// реверс* после максимального закрытия открывает жалюзи для работы в авт режиме  
  if (stepper.isDone()&&Port == 0 && Auto == true && Revers == false ) {
    stepper.setDirection(CCW);            // открываем 
    stepper.rotateDegrees(270);
    digitalWrite(PinLRED, LOW );          // гасим крсный свет диода 
    AutoMod = 0;                          // говорим что жалюзи открыты
    Revers = !Revers;                     // говорим что реверс сделан (поднимаем флаг)
  }

// выход из авто режима
  if ( stepper.isDone()&& irrecv.decode(&results)&& Auto == true){
    switch (results.value) {              // ИК почемуто с обычным циклом не заработал поэтому switch
      case Exit :                         // не смог сделать так чтобы и вход и выход в авт режим были на одной кнопке 
       Auto = !Auto ;                     // говорим что вышли из авт режима (опускаем флаг)
       Revers = !Revers;                  // обнуляем реверс (опускаем)
      break;
    }
   irrecv.resume();                       // возврощаем ИК приемник в режим считывания (если не возвратить то на нем всегда будет то значение которое мы прочитали в первый раз)                  
  }

//открывание и закрывание жалюзи в ручном режиме + переход в авто
  if (Port == 0 && Auto == false){
   if ( stepper.isDone()&& irrecv.decode(&results)){
    switch (results.value) {
      case UP :
       stepper.setDirection(CW);            // Устанавливает направление вращения. Может принимать 3 значения: CW - по часовой, CCW - против часовой, STOP
       stepper.rotateDegrees(5);            // поворачиваем на 5 градусов
       mod = 1 ;// дороботать эту хрень
      break;

      case DWN :
       stepper.setDirection(CCW);           // Устанавливает направление вращения. Может принимать 3 значения: CW - по часовой, CCW - против часовой, STOP
       stepper.rotateDegrees(5);            // поворачиваем на 5 градусов
       mod = 1 ;// дороботать эту хрень
      break;

      case Change :
       digitalWrite(PinLRED, HIGH );
       Auto = !Auto ;                      // говорим что авто режим включен (поднимаем флаг)
       stepper.setDirection(CW);           // Устанавливает направление вращения. Может принимать 3 значения: CW - по часовой, CCW - против часовой, STOP
       stepper.rotateDegrees(350);         // вращаем до упора и чуть чуть еще. В положение "открыто" вернется с помощью реверс*.
       
       mod = 1 ;
      break;
    }
   irrecv.resume();                        // возврощаем ИК приемник в режим считывания (если не возвратить то на нем всегда будет то значение которое мы прочитали в первый раз)                  
   }  
  }

// отправка команд на степпер (если небыло команд и отправили пустоту то прога виснет )  
  if(mod>0){                            // ВАЖНО !!! если не было никаких команд на степпер и написать stepper.run(); то программа остановится и будет висеть на  этой строчке !!!!
    stepper.run();                        // отправляет команды на степпер ОБЯЗАТЕЛЬА в цикле loop 
   }

//END}
